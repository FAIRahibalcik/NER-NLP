from typing import Any
import pandas as pd
import numpy as np
import re
import string
import os
import json
import spacy
from spacy.matcher import Matcher
from spacy.tokens import Span

class CustomNER(object):
    def __init__(self):
        # # # unnecessary since this will be provided 
        # self.df_data = pd.read_parquet(os.path.expanduser("~/Downloads/NewsData_Samsung-Electronics.parquet"), engine="auto")

        self.comp_index = pd.read_csv(os.path.expanduser("~/Downloads/kospi200_info_v3_Ahmet.csv"))
        self.comp_index.eng_name_clean = self.comp_index.eng_name_clean.astype(str)
        self.clean_names = self.comp_index.eng_name_clean.tolist()

        # forming a reference dictionary to extract id and lookup name later

        name_id_dict = {}
        for i in range(len(self.clean_names)):
            name_id_dict[self.comp_index.at[i, "eng_name_clean"].upper()] = (self.comp_index.at[i, "corp_code"], self.comp_index.at[i, "eng_name"].upper(), self.comp_index.at[i, "eng_name_clean"].upper())
        self.index_dict = name_id_dict

        self.entity_type = ["ORG", "PERSON", "PRODUCT", "GPE"]

        # # preprocessing in progress

        # def extract4sentence(self, text):
        #     eng = re.compile('[\n]')
        #     result = eng.sub(' ', text)
        #     result = ' '.join(result.split())
        #     return result


        # def simp_preprop(self, df):
        #     print('Removing missing values...')
        #     df = df[~df['summary'].isna()].reset_index()

        #     print('Preprocessing...')
        #     contents = df.title + '.\n' + df.summary
        #     df['contents'] = contents.apply(lambda x: extract4sentence(self, x))

        #     # sentseg = spacy.load("en_core_web_md")
        #     # df['contents'] = df['contents'].apply(lambda x : '. '.join([x.text for x in sentseg(x).sents]))

        #     return df

        # self.df_trial = simp_preprop(self.df_data)

        self.nlp = spacy.load("en_core_web_trf", exclude=["tagger", "lemmatizer", "morphologizer", "textcat"])


    def myconverter(self, obj):
            if isinstance(obj, np.generic):
                return obj.item()


    def lowercase_translator(self, my_string):
            return my_string.lower().translate(str.maketrans('', '', string.punctuation))


    def det_comp_list(self, doc):
            detected_list = []
            for ent in doc.ents:
                if ent._.is_company == "COMP":
                    detected_list.append(ent)
            return detected_list


    def longest_company_name(self, a_list, doc):
        if len(a_list) > 0:
            long_comp = a_list[0]
            for a in a_list:
                if len(a.text) > len(long_comp.text):
                    long_comp = a
        else:
            long_comp = doc[0:0]
        return long_comp


    def NLP_results(self, doc, index_dict):

        nlp = self.nlp
        doc = nlp(doc)
        names = [key for key in index_dict]

        # building up patterns and matcher

        patterns = list(nlp.pipe(names))
        final_pattern = []
        matcher = Matcher(nlp.vocab)
        for i in range(len(patterns)):
            another_list = []
            for token in patterns[i]:
                another_list.append({"LOWER": token.text.lower()})
            final_pattern.append(another_list)
            #  (DEPRECATED) final_pattern.append([{"LOWER": "samsung"}])
            matcher.add(names[i].upper(), final_pattern)
            final_pattern = []
        matches = matcher(doc)

        # setting extensions and deciding company attribute of recognized entities

        Span.set_extension("is_company", default=None, force=True)
        Span.set_extension("lookup_name", default=None, force=True)
        Span.set_extension("company_id", default=None, force=True)

        for ent in doc.ents:
            if ent.label_ == "ORG":
                for match_id, start, end in matches:
                    if nlp.vocab.strings[match_id] in ent.text.lower():
                        ent._.is_company = "COMP"
                    elif CustomNER.lowercase_translator(self, ent.text) in CustomNER.lowercase_translator(self, nlp.vocab.strings[match_id]):
                        ent._.is_company = "COMP"
                    elif CustomNER.lowercase_translator(self, nlp.vocab.strings[match_id]) in CustomNER.lowercase_translator(self, ent.text):
                        ent._.is_company = "COMP"

        a_list = CustomNER.det_comp_list(self, doc)

        for ent in doc.ents:
            if ent.label_ == "ORG":
                for a in a_list:
                    if a.text in ent.text:
                        ent._.is_company = "COMP"


        # setting extensions and deciding lookup name and ID attributes of recognized entities

        for ent in doc.ents:
            if ent.label_ == "ORG":
                for match_id, start, end in matches:
                    if self.nlp.vocab.strings[match_id] in ent.text.lower():
                        ent._.lookup_name = index_dict[nlp.vocab.strings[match_id]][1]
                        ent._.company_id = index_dict[nlp.vocab.strings[match_id]][0]
                    elif CustomNER.lowercase_translator(self, nlp.vocab.strings[match_id]) in CustomNER.lowercase_translator(self, ent.text):
                        ent._.lookup_name = index_dict[nlp.vocab.strings[match_id]][1]
                        ent._.company_id = index_dict[nlp.vocab.strings[match_id]][0]

        # linking non-pronoun references to main company entity info (used a simple logic: longest is the best)

        while len(a_list) > 1:
            long_comp = CustomNER.longest_company_name(self, a_list, doc)
            for elm in a_list:
                if elm.text in long_comp.text and elm is not long_comp:
                    elm._.lookup_name = long_comp._.lookup_name
                    elm._.company_id = long_comp._.company_id
                    a_list.remove(elm)
            a_list.remove(long_comp)

        # preparing objects and values for final dictionary buildup

        sent_num = len([sent for sent in doc.sents])

        sent_i_dict = {}
        for sent_index, sent in enumerate(doc.sents):
            sent_i_dict[sent] = sent_index

        sent_with_ent = set()
        for ent in doc.ents:
            sent_with_ent.add(sent_i_dict[ent.sent])
        sent_with_ent_num = len(sent_with_ent)

        sent_with_comp = set()
        for ent in doc.ents:
            if ent._.is_company == "COMP":
                sent_with_comp.add(sent_i_dict[ent.sent])
        sent_with_comp_num = len(sent_with_comp)

        detected_companies_set = set()
        for ent in doc.ents:
            if ent._.is_company == "COMP":
                detected_companies_set.add(ent.text)
                detected_companies_set.add(ent._.lookup_name)

        freq_list = list(doc.ents[:])
        freq_dict = {}
        for ent in freq_list:
            if ent._.lookup_name is not None:
                if ent._.lookup_name in freq_dict.keys():
                    freq_dict[ent._.lookup_name][0] += 1
                    freq_dict[ent._.lookup_name][1].append(sent_i_dict[ent.sent])
                else:
                    freq_dict[ent._.lookup_name] = [1, [sent_i_dict[ent.sent]]]
            else:
                if ent.text in freq_dict.keys():
                    freq_dict[ent.text][0] += 1
                    freq_dict[ent.text][1].append(sent_i_dict[ent.sent])
                else:
                    freq_dict[ent.text] = [1, [sent_i_dict[ent.sent]]]
        for key in freq_dict.keys():
            freq_dict[key].append(round(freq_dict[key][0]/sent_num, 2))
            freq_dict[key].append(round(freq_dict[key][0]/sent_with_ent_num, 2))
            if key in detected_companies_set:
                freq_dict[key].append(round(freq_dict[key][0]/sent_with_comp_num, 2))

        # list_of_dict_per_ent --> lodpe
        # dict_per_ent (explanatory naming) = {Entity Name, Entity Label, Company Recognizer,
        #                                      Lookup Name, Company ID, Frequency,
        #                                      Parent Sentence Indices,
        #                                      Ratio with respect to number of all sentences,
        #                                      Ratio with respect to number of sentences including entities,
        #                                      Ratio with respect to sentences containing company entities}
        # dict_per_ent (real naming) = {name, label, comp_or_not, lookup_name,
        #                               comp_id, freq, parent_sent_i, ratio_wrt_all_sent,
        #                               ratio_wrt_ent_sent, ratio_wrt_comp_sent}

        lodpe = []
        name_list = []
        for ent in doc.ents:
            if ent.label_ in self.entity_type:
                if ent.text not in name_list and ent._.lookup_name not in name_list:
                    dict_per_ent = {"name": ent.text, "label": ent.label_, "comp_or_not": ent._.is_company,
                                    "lookup_name": ent._.lookup_name, "comp_id": ent._.company_id}
                    if ent._.lookup_name in freq_dict.keys():
                        dict_per_ent["name"] = ent._.lookup_name
                        dict_per_ent["freq"] = freq_dict[ent._.lookup_name][0]
                        dict_per_ent["parent_sent_i"] = freq_dict[ent._.lookup_name][1]
                        dict_per_ent["ratio_wrt_all_sent"] = freq_dict[ent._.lookup_name][2]
                        dict_per_ent["ratio_wrt_ent_sent"] = freq_dict[ent._.lookup_name][3]
                        dict_per_ent["ratio_wrt_comp_sent"] = freq_dict[ent._.lookup_name][4]
                    elif ent._.is_company == "COMP":
                        dict_per_ent["freq"] = freq_dict[ent.text][0]
                        dict_per_ent["parent_sent_i"] = freq_dict[ent.text][1]
                        dict_per_ent["ratio_wrt_all_sent"] = freq_dict[ent.text][2]
                        dict_per_ent["ratio_wrt_ent_sent"] = freq_dict[ent.text][3]
                        dict_per_ent["ratio_wrt_comp_sent"] = freq_dict[ent.text][4]
                    else:
                        dict_per_ent["freq"] = freq_dict[ent.text][0]
                        dict_per_ent["parent_sent_i"] = freq_dict[ent.text][1]
                        dict_per_ent["ratio_wrt_all_sent"] = freq_dict[ent.text][2]
                        dict_per_ent["ratio_wrt_ent_sent"] = freq_dict[ent.text][3]
                    lodpe.append(dict_per_ent)
                    name_list.append(ent.text)
                    if ent._.lookup_name is not None:
                        name_list.append(ent._.lookup_name)

        lodpe = json.dumps(lodpe, default = CustomNER.myconverter(self, obj=np.generic))
        return(lodpe)

# print(NLP_results(document, name_id_dict))
a = CustomNER()
t = "LG TV Morphs From Flat Screen to Curved With Press of a Button. LAS VEGASâ€”You can buy a flat-screen TV or a curved one. But why not one that can do both? LG Display has your number. Here at CES, the Korean manufacturer is showing off a 4K OLED TV that can morph from a flat panel into a curved display with the press of a button. The concept TV flips between the two modes in about 5 seconds. It's a cool trick, and can let the viewer get a more immersive view and audio experience when the panel switches into the curved panel mode. LG Display envisions the concept TV for use in both home entertainment and on first-class airplane flights. A rep said the panel can bend back and forth about 35,000 times. The manufacturer built the TV using its bendable OLED Display technology, which it's been researching for years. At CES 2018, the same technology grabbed headlines when LG Display used it in a rollable 4K 65-inch TV, which rose up from a spindle. At this year's CES, the rollable display has returned, but it can now unfurl downwards like a movie projection screen. LG Display has been demonstrating the rollable concept as a convenient way for people to store and access a large TV whenever they need it. The company can't really say when any of these display concepts will hit the market; that's up to the vendors. LG Display is a separate business unit from LG Electronics and it refrains from selling products directly to consumers. Its focus is to sell to vendors, which can then put the technologies into their TVs, phones, laptops, and more. That said, CNET reports that LG Electronics plans on selling a rollable TV in the second or third quarter for a whopping $60,000. LG Display declined to discuss pricing, but said the technology is ready for production. At CES, the manufacturer also demonstrated other ways the company's bendable OLED panels can be used to help consumer electronics stand out. This included using it to create a foldable 13.3-inch tablet/laptop with a screen resolution of 1,536 by 2,048. What was interesting about the concept was how it also curved over the edge of the tablet to display notifications including the battery life, Wi-Fi connection signal, and the time. LG says the foldable panel will be ready for mass production next quarter. This newsletter may contain advertising, deals, or affiliate links. Subscribing to a newsletter indicates your consent to our Terms of Use and Privacy Policy. You may unsubscribe from the newsletters at any time."
print(a.NLP_results(t, a.index_dict))